\color{finishing}

\section{Konzeption}

In diesem Kapitel werden die Anforderungsdefinitionen des Projektes, mit Spezialisierung auf die verschiedenen Use Cases beschrieben.

\subsection{Anforderunsdefinitionen}

Ein Schwarmverhalten zur Interaktion von Kleinroboter benötigt verschiedene Anforderungen, um korrekt untereinander agieren zu können. Die Basis hierbei bildet das Kommunikationssystem zwischen den einzelnen Komponenten, um erfasste Daten zuverlässig zu synchronisieren. Um die Daten entsprechend zu interpretieren benötigt jede Komponente den jeweiligen Aufbau der Kommunikation, damit diese verwertet und Aktionen ausgeführt werden können.\\
Diese Aktionen repräsentieren den Grundbestandteil des Schwarmverhaltens und sind auf die verschiedenen Systeme verteilt. Die Roboter benötigen hierbei implementierte Funktionen, wie das Ansteuern von Motoren, Sensorik, sowie die Aktualisierung, um erfasste Daten an Nutzer weiterzuleiten. Zur Steuerung dient eine App für mobile Smartphones mit einem \gls{ui} um verschiedene Szenarien zu starten, sowie die Roboter kontrollieren zu können. Die Kontrollschnittstelle stellt dabei eine Desktopanwendung dar, über die der Nutzer mit den Robotern kommuniziert und Daten zur Steuerung abgreifen kann, wobei mehrere Nutzer zur selben Zeit mit verschiedenen Szenarien unterstützt werden sollen.\\

\noindent
Damit bestehen folgende Anforderungsdefinitionen an die zu erstellenden Softwarekomponenten:
\begin{itemize}
	\item Kommunikationssystem
	\item Interpretation
	\item \gls{ui}
	\item Steuerungsfunktionen
\end{itemize}

\newpage
\subsection{Softwarearchitektur}

Die Architektur des Schwarmverhaltens besteht aus drei Hauptkomponente, den Robotern, einer Desktopanwendung, sowie einer mobilen App, siehe Abbildung \ref{fig:softwarearchitecture}.\\
Diese Komponenten kommunizieren über ein drahtloses Netzwerk mittels \gls{tcp} untereinander, indem diese Zeichenketten als \gls{json} versenden. Dadurch lassen sich gesammelte Daten als Objekte kapseln und auf den verschiedenen Systemen entsprechend synchronisieren. Dies geschieht über eine Klassenstruktur, die Kommandos abbildet, durch die die kommunizierten Daten serialisiert und als Objekte dargestellt werden können.\\
Die Roboter basieren auf dem Java System \gls{lejos}, da durch die bereitgestellten Bibliotheken für \gls{ev3} Systeme eine unkomplizierte Implementierung von Logik möglich ist, sowie eine direkte Unterstützung von \gls{eclipse} gegeben ist, um erstellte Software zu debuggen. Die Roboter unterstützen für ein Schwarmverhalten klassische Funktionen, um die Daten der vorhandenen Sensorik auszulesen, sowie Motoren anzusteuern. Diese Funktionen werden einerseits durch Kommandos ausgeführt um den entsprechenden Roboter zu steuern. Anderseits werden regelmäßig Daten durch einen Prozess erfasst, um diese auf dem Backend zu aktualisieren.\\
Die App beruht auf der plattformübergreifenden Implementierung mittels des Frameworks Xamarin um möglichst viele Systeme zu erreichen. Sie baut dabei auf ein einfaches \gls{ui} mit dem Design Pattern \gls{mvvm} auf, um diese von der eigentlichen Logik zu trennen und einen qualitativ hochwertigen Quellcode zu schaffen, der einfach gewartet werden kann. Die App besitzt Basisfunktionen zur Erstellung von Kommandos, die die Verwaltung von Szenarien veranlassen und steuert somit den Schwarm.\\
Das Backend dient als Kommunikationsschnittstelle des gesamten Systems und steuert die Kommandos für den Ablauf der Szenarien. Es besitzt ein \gls{ui} mit \gls{javafx} Realisierung zur Anzeige von erfassten Daten der einzelnen Komponenten und stellt diese anhand einer auswählbaren Hierarchie dar.

\newpage
\begin{verbatim}
\end{verbatim}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.65\textwidth]{images/konzeption/Softwarearchitecture.png}
	\caption{Softwarearchitektur}
	\label{fig:softwarearchitecture}
\end{figure}

\newpage
\subsection{Steuerung}

Die Steuerung des Roboterschwarms greift in sämtlich implementierten Szenarien auf die Sensorik des Smartphones als Basis zurück. Verwendet werden hierbei die Bewegungssensoren um eine Steuerung durch das Hin- und Herschwenken des Smartphones zu ermöglichen. Dies stellt eine intuitive Steuerung dar und ist für jeden neuen Nutzer schnell begreiflich. In Abbildung \ref{fig:steuerung} ist die entsprechende Steuerung zur Bewegung des Roboters dargestellt. Um die Roboter möglichst genau zu steuern, erfasst die Sensorik laufend Daten, welche im \gls{ui} angezeigt werden. Dadurch lässt sich eine Veränderung der Daten darstellen, die zu einer signifikant verbesserten Steuerung führen.\\

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\textwidth]{images/Controling.png}
	\caption{Steuerung}
	\label{fig:steuerung}
\end{figure}

\subsection{Szenarien}

Zum Ablauf der Software greift der Roboterschwarm auf verschieden definierte Szenarien als Kontext zurück. Diese sind in Control, Synchron, Follow, Flee und Catch untergliedert, wobei ein Single mit einem Nutzer oder einem Mehrnutzersystem als Multi unterschieden wird. Der Multi Mode dient hierbei als Erweiterung zur Software und ist im vorliegenden System nicht implementiert und kann daher nicht genutzt werden. Folgend werden die einzelnen Szenarien beschrieben, die als Kontext für ein Schwarmverhalten genutzt werden können.

\paragraph{Control}

stellt eine direkte Steuerung eines einzelnen Roboters und fällt somit nicht unter die Kategorie Schwarmverherhalten. Dieses Szenario dient zur Entwicklung der grundlegenden Funktionen, auf denen das Schwarmverhalten und damit weitere Szenarien aufbauen.

\paragraph{Synchron}

stellt eine synchrone Steuerung von mehreren Robotern dar, in dessen Kontext jeder beteiligte Roboter identische Kommandos erhält. Durch eine entsprechende Aufstellung der Roboter lassen sich Schwärme aus dem Tierreich, wie Fische oder Vögel nachahmen.

\paragraph{Follow}

stellt eine Reihe von Robotern dar, indem der vorderste vom Nutzer gesteuert werden kann. Die restlichen Roboter erhalten ihrer Position in der Schlange entsprechend der Position ihres Vordermannes, zu dem diese vollkommen autonom fahren. Da diese Ablauf laufend wiederholt wird, stellen alle Roboter gesamt eine Schlange dar, wobei die einzelnen die Muskeln und der vorderste Roboter den Kopf repräsentiert.

\paragraph{Flee}

stellt ein Verfolgungsszenario dar, indem der Nutzer mit seinem Roboter vor anderen flieht. Dabei erhalten die restlichen Roboter laufend eine Position um immer näher an diesen heranzufahren. Sollte der Nutzer durch einen Roboter erwischt werden, ertönt ein Endsignal , wobei anschließend das Szenario beendet wird.

\paragraph{Catch}

stellt ein Verfolgungsszenario dar, indem der Nutzer die restlichen Roboter fängt. Diese fahren zufällig in verschiedene Richtungen davon. Sollte der Nutzer alle gefangen haben, ertönt ein Signal und beendet damit das Szenario.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{images/logos/UWP/FleeAndCatch_Logo.png}
	\end{center}
	\caption{Logo}
	\label{fig:Logo}
\end{figure}

\newpage
\color{process}
\subsection{Use Cases}

In diesem Abschnitt werden die Use Cases des Schwarmverhaltens beschrieben. Dabei wird insbesondere auf den Ablauf in Form von \gls{uml} Diagrammen eingegangen.

\subsubsection{Connection}

Im Use Case Connection wird durch die Eingabe einer IP-Adresse eine drahtlose Verbindung über das verbundene Netzwerk zur Desktopanwendung aufgebaut. Dabei erhält jede Komponente zur Unterscheidung eine individuelle Identifikation, durch eine fortlaufende Nummer. Um eine entsprechende Reaktionsgeschwindigkeit während eines Szenarios garantieren zu können, wird zum Verbindungsaufbau eine Initialisierung durchgeführt. in deren Ablauf wird in regelmäßigen Zeitabständen Daten zwischen der Desktopanwendung und der Komponente hin- und herversendet, bis diese erreicht ist. Dies macht bei der App keinen Unterschied, bei Roboter jedoch wird erst bei entsprechender Beanspruchung des Threads eine längere CPU-Laufzeit freigegeben und somit eine Reaktionsverzögerung während eines Szenarios vermieden.\\
Allgemein wird für diesen Use-Case unter zwei Typen unterschieden, dem Connection, Disconnection, wobei entsprechend eine Verbindung auf, oder abgebaut wird. Die eingegbene IP-Adresse kann dabei in einer internen SQLite-DB hinterlegt werden, um diese nicht erneut eingeben zu müssen. Hierbei wird immer die zuletzt gespeicherte automatisch eingetragen.

\begin{figure}[h]
	\centering
	\subfloat[Log in]{\includegraphics[width=0.25\textwidth]{images/mockups/Connection.png}\label{fig:Connect}}
	\qquad
	\subfloat[Home]{\includegraphics[width=0.25\textwidth]{images/mockups/Home.png}\label{fig:Home}}
	\caption{Mockup Connection}
\end{figure}
\newpage
\begin{verbatim}
\end{verbatim}
\begin{figure}[h]
	\begin{center}
		\includegraphics[width=1\textwidth]{images/use_cases/Connect.png}
	\end{center}
	\caption{Use Case Connect}
	\label{fig:UC_Connect}
\end{figure}

\newpage
\subsubsection{Synchronization}

Im Use Case Synchronization werden Daten entsprechend des gesetzten Typen im Kommando versendet. Hierbei werden Roboter von ganzen Szenarien unterschieden, wobei ein Roboter, alle vorhandenen ROboter, oder Szenarien aktualisiert werden können. Die Aktualisierung der ROboter dient dabei zu Anfang zum Auswahl der beteiligten Roboter, sowie dem SZenario. Der einzele ROboter dient dem aktualisieren der hinterlegten Daten der Desktopanwendung, sowie der App, wobei diese direkt in der \gls{ui} angezeigt werden können. Die Übertragung der gesamten Szenarios, dient dem Spectator, um eine aktuell laufendes Szenario einzusehen, wobei anschließen nur das aktuelle Szenario übertragen wird, welches der Nutzer ausgewählt hat.

\begin{figure}[h]
	\centering
	\subfloat[Log in]{\includegraphics[width=0.25\textwidth]{images/mockups/RobotList.png}\label{fig:Synchronization_1}}
	\qquad
	\subfloat[Home]{\includegraphics[width=0.25\textwidth]{images/mockups/Control.png}\label{fig:Synchronization_2}}
	\caption{Mockup Synchronization}
\end{figure}
\newpage
\begin{verbatim}
\end{verbatim}
\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{images/use_cases/Synchronization.png}
	\end{center}
	\caption{Use Case Synchronization}
	\label{fig:UC_Synchronization}
\end{figure}
\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.3\textwidth]{images/use_cases/Update.png}
	\end{center}
	\caption{Use Case Update}
	\label{fig:UC_Update}
\end{figure}

\newpage
\subsubsection{Szenario}

Im Use Case Szenario wird der Ablauf der definierten Szenarien zur Steuerung der Roboter dargestellt. Dabei wird zunächst vom Nutzer das jeweilige Szenario mit den teilnehmenden Robotern ausgewählt und anschließend durch ein Kommando mit dem Typen Begin getstartet. Hierbei erhält das Backend das erstellte SZenario und behandelt es entsprechend der Definition, wobei es ein STeuerungskommando oder ein Positionskommando an den ROboter weiterleitet.\\
Der SInn hierbei ist, dass die Intelligenz auf dem Backend ausgelagert wird, um die Resourcen der Roboter zu schonen, wobei diese lediglich Steuerungskommandos erhalten, oder minimierte autonome Positionen anfahren können. Das Szenariokommando wird dabei laufend erneut gesendet, um aktuelle Daten, wie Steuerungsinformation durch die Motion Sensoren weiterzuleiten.
 
\begin{figure}[h]
	\centering
	\subfloat[Szenario]{\includegraphics[width=0.25\textwidth]{images/mockups/Control.png}\label{fig:Szenario_1}}
	\qquad
	\subfloat[Spectator]{\includegraphics[width=0.25\textwidth]{images/mockups/Spectator.png}\label{fig:Szenario_2}}
	\caption{Mockup Szenario}
\end{figure}
\newpage
\begin{verbatim}
\end{verbatim}
\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{images/use_cases/Szenario.png}
	\end{center}
	\caption{Use Case Szenario}
	\label{fig:UC_Szenario_1}
\end{figure}
\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.35\textwidth]{images/use_cases/Spectator.png}
	\end{center}
	\caption{Use Case Spectator}
	\label{fig:UC_Szenario_2}
\end{figure}

\newpage
\subsubsection{Exception}

Im Use Case Exception wird die das Auftreten einer Exception im Kontext eines Verbindungsverlustes behandelt. Dabei wird der beteiligte Komponente, wie die auftretende Nachricht an das Backend weitergeleitet. 

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.5\textwidth]{images/use_cases/Exception.png}
	\end{center}
	\caption{Use Case Exception}
	\label{fig:Exception}
\end{figure}

\newpage
\subsection{Kommunikation}