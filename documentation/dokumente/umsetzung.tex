\section{Implementierung}

In diesem Kapitel wird die Implementierung des Projektes mit Fokussierung auf die einzelnen Komponenten beschrieben.

\subsection{Kommunikation}

Die Kommunikation der einzelnen Komponenten des Schwarmverhaltens baut auf einer klar definierten Struktur, um ein verteiltes System zu ermöglichen, siehe \ref{fig:full_classdiagram}. Die Daten werden dabei als \gls{json} Objekte zur optimalen plattformübergreifenden Interpretation versendet, wobei jeweils die entsprechende Bibliothek zur Serialisierung verwendet wird.
\begin{verbatim}
\end{verbatim}
\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.95\textwidth]{images/uml/full_class_diagram.png}
	\end{center}
	\caption{Aufbau Commands}
	\label{fig:full_classdiagram}
\end{figure}

\newpage
\noindent
Der Kern zur Implementierung der Kommunikation erfolgt in zwei Methoden, die auf jeder Komponente zur Verfügung stehen. Diese dienen zum Versenden, sowie Empfangen von Daten, wobei diese als Zeichenkette serialisiert und in Bytes aufgeteilt werden, siehe Abbildung \ref{fig:SendCommand}. Um den vollständigen Umfang der Daten zu erfassen, wird die Größe ermittelt und standardmäßig mittels vier Bytes übertragen. Dadurch ist eine maximale Paketgröße von 32 Byte möglich, was einer Länge von etwa 4 Milliarden Zeichen entspricht. Die Interpretation zum Empfangen erfolgt mit ähnlichem Muster, indem zunächst die Größe der Daten festgestellt wird und die Daten deserialiert werden, siehe Abbildung \ref{fig:ReceiveCommand}.

\begin{figure}[h]
	\centering
	\subfloat[Versende Kommando]{\includegraphics[width=0.6\textwidth]{images/code/SendCommand.png}\label{fig:SendCommand}}
	\qquad
	\subfloat[Empfange Kommando]{\includegraphics[width=0.6\textwidth]{images/code/ReceiveCommand.png}\label{fig:ReceiveCommand}}
	\caption{Kommunikation}
\end{figure}

\newpage
\paragraph{Kommando}

\begin{wrapfigure}{r}{0.55\textwidth}
	\begin{center}
		\includegraphics[width=0.5\textwidth]{images/uml/commands.png}
	\end{center}
	\caption{Kommandos}
	\label{fig:commands_classdiagram}
	\begin{center}
		\includegraphics[width=0.5\textwidth]{images/uml/identification.png}
	\end{center}
	\caption{Identifikation}
	\label{fig:identification_classdiagram}
\end{wrapfigure}

Objekte stellen die Basis der Kommunikationsstruktur sowie den aktuellen Kontext dar, in dem sich die Software befindet, siehe \ref{fig:commands_classdiagram}. Sie enthalten grundlegende Attribute zur allgemeinen Identifikation des Kommandos, die zur Interpretation verwendet werden. Je nach Kommando sind zusätzliche Objekte enthalten, die durch die jeweilige Id vordefiniert sind.\\

\paragraph{Identifikation}

Objekte stellen wie ihr Name die einzlnen Komponenten, mit ihren definierten Attributen dar un dienen eldiglich der Identifikation, von welcher Komponente das aktuelle KOmmando stammt. DIese Objekte sind daher in allesn definierten Kommandos zu finden.

\newpage
\paragraph{Geräte}

\begin{wrapfigure}{r}{0.55\textwidth}
	\begin{center}
		\includegraphics[width=0.5\textwidth]{images/uml/devices.png}
	\end{center}
	\caption{Devices}
	\label{fig:devices_classdiagram}
	\begin{center}
		\includegraphics[width=0.5\textwidth]{images/uml/szenarios.png}
	\end{center}
	\caption{Scenarios}
	\label{fig:szenarios_classdiagram}
\end{wrapfigure}

Die Device Objekte stellen die KOmponenten im ganzen dar und enthalten zu speziellen Identifikations Attribute die allgemeinen Daten, sowie die Steuerungsoperatoren. Dabei wird unter den zwei existierenden KOmponenten unterschieden und kann durch einen vorliegenden COnverter serialisiert werden.

\paragraph{Szenarios}
Die Szenarios stellen den aktuellen Kontext des Schwarmverhaltens dar und enthalten zu Identifikations Attributen zusätzliche die teilnehmenden Devices um diese zuordnen zu könnn. Diese Objekte werden laufend aktualisiert und haben nur zur Laufzeit des entsprechenden Szenarios ihre Gültigkeit, wobei sie bei Beendigung gelöscht werden.

\newpage
\paragraph{Konverter}
\begin{wrapfigure}{r}{0.55\textwidth}
	\begin{center}
		\includegraphics[width=0.5\textwidth]{images/uml/json_converter.png}
	\end{center}
	\caption{JSON Converter}
	\label{fig:converter_classdiagram}
\end{wrapfigure}

Um Objekte spezifisch zu abstrahieren, werden sogenannte Converter verwendet, um abstrahierte Objekte direkt abgeleiteten Klassen zuzuordenn und entsprechende Programmlogik auszuführen. Dabei wird auf die entsprechende Bibliothek mit Grundlogik zurückgegriffen und entsprechende Bedingungen hinzugefügt. siehe \ref{fig:converter_classdiagram}



\newpage
\subsection{App}

\subsubsection{Workflow} %Struktur

\paragraph{Design Pattern}
\paragraph{\acrfull{mvvm}}
\paragraph{Bindings}

\subsubsection{\acrfull{gui}} %Oberfläche

\subsubsection{Buisnesslogic} %Logik

\subsection{Backend}

\begin{comment}
Aufbau
Interpreter
Mechanismen
GUI
\end{comment}

\subsection{Robot}

\begin{comment}
Aufbau
Robot
RobotController
EV3 Library
GUI
\end{comment}