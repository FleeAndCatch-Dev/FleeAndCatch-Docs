\section{Implementierung}

In diesem Kapitel wird die Implementierung des Projektes mit Fokussierung auf die einzelnen Komponenten beschrieben.

\subsection{Kommunikation}

Die Kommunikation der einzelnen Komponenten des Schwarmverhaltens baut auf einer klar definierten Struktur, um ein verteiltes System zu ermöglichen, siehe Abbildung \eqref{fig:full_classdiagram}. Die Daten werden dabei als \gls{json} Objekte zur optimalen plattformübergreifenden Interpretation versendet, wobei jeweils die entsprechende Bibliothek zur Serialisierung verwendet wird.
\begin{verbatim}
\end{verbatim}
\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.95\textwidth]{images/uml/full_class_diagram.png}
	\end{center}
	\caption{Aufbau Commands}
	\label{fig:full_classdiagram}
\end{figure}

\newpage
\noindent
Der Kern zur Implementierung der Kommunikation erfolgt in zwei Methoden, die auf jeder Komponente zur Verfügung stehen. Diese dienen zum Versenden, sowie Empfangen von Daten, wobei diese als Zeichenkette serialisiert und in Bytes aufgeteilt werden, siehe Abbildung \ref{fig:SendCommand}. Um den vollständigen Umfang der Daten zu erfassen, wird die Größe ermittelt und standardmäßig mittels vier Bytes übertragen. Dadurch ist eine maximale Paketgröße von 32 Byte möglich, was einer Länge von etwa 4 Milliarden Zeichen entspricht. Die Interpretation zum Empfangen erfolgt mit ähnlichem Muster, indem zunächst die Größe der Daten festgestellt wird und die Daten deserialiert werden, siehe Abbildung \ref{fig:ReceiveCommand}.

\begin{figure}[h]
	\centering
	\subfloat[Versende Kommando]{\includegraphics[width=0.6\textwidth]{images/code/SendCommand.png}\label{fig:SendCommand}}
	\qquad
	\subfloat[Empfange Kommando]{\includegraphics[width=0.6\textwidth]{images/code/ReceiveCommand.png}\label{fig:ReceiveCommand}}
	\caption{Kommunikation}
\end{figure}

\newpage
\paragraph{Kommandos}

\begin{wrapfigure}{r}{0.55\textwidth}
	\begin{center}
		\includegraphics[width=0.5\textwidth]{images/uml/commands.png}
	\end{center}
	\caption{Kommandos}
	\label{fig:commands_classdiagram}
	\begin{center}
		\includegraphics[width=0.5\textwidth]{images/uml/identification.png}
	\end{center}
	\caption{Identifikation}
	\label{fig:identification_classdiagram}
\end{wrapfigure}

stellen die Basis der Kommunikationsstruktur sowie den aktuellen Kontext dar, indem sich die Software befindet, siehe Abbildung \ref{fig:commands_classdiagram}. Sie enthalten grundlegende Attribute zur allgemeinen Identifikation des Kommandos, die zur Interpretation verwendet, welche über definierte Enums ausgewählt werden. Je nach Kommando sind zusätzliche Objekte enthalten, die durch die jeweilige Id vordefiniert sind.\\

\paragraph{Identifikationen}

stellt die individuelle Identität der einzelnen Komponente dar, siehe Abbildung \ref{fig:identification_classdiagram}. Diese wird durch eine fortlaufende Identifikationsnummer, Typen und je nach Ableitung weiteren Attributen erreicht. Um die jeweiligen Kommandos entsprechend zuzuordnen, sind diese in jedem Kommando vorhanden und bilden die Basisobjekte. Die unterschiedlichen Typen sind dabei für verschiedene Kontexte der Software zuständig. Die ClientIdentification stellt einerseits die Verbindung einer allgemeinen Komponente zur Desktopanwendung dar, wogegen die Robot- bzw. AppIdentification die spezifische Identifikation der Komponente darstellt. Die Erstellung der Identifikation erfolgt wiederholt zur Anmeldung der Komponente am System. Zunächst wird ein leeres Objekt erzeugt, dass anschließend durch abfragende Kommandos an die entsprechende Komponente befüllt wird, welche hinterher eine berechnete Identifikationsnummer erhält.

\newpage
\paragraph{Geräte}

\begin{wrapfigure}{r}{0.55\textwidth}
	\begin{center}
		\includegraphics[width=0.5\textwidth]{images/uml/devices.png}
	\end{center}
	\caption{Devices}
	\label{fig:devices_classdiagram}
	\begin{center}
		\includegraphics[width=0.5\textwidth]{images/uml/szenarios.png}
	\end{center}
	\caption{Scenarios}
	\label{fig:szenarios_classdiagram}
\end{wrapfigure}

stellen die Komponenten dar, die an einem Szenario eines Schwarmverhaltens teilnehmen, siehe Abbildung \ref{fig:devices_classdiagram}. Sie enthalten jeweils spezifische Identifikations Objekte, zur gegenseitigen Zuordnung, sowie die erfassten Daten der entsprechenden Systeme. Die Unterscheidung erfolgt in zwei Komponenten, dem Robot und der App, wobei der Roboter in die jeweiligen Untertypen gegliedert werden kann. 

\paragraph{Szenarios}

stellen den Ablauf des Schwarmverhaltens dar, in dem sich der Nutzer befindet, siehe Abbildung \ref{fig:szenarios_classdiagram}. Sie enthalten die jeweiligen Teilnehmer des Szenarios, sowie die Steuerungsinformationen und damit die gesamten Daten des aktuellen Kontextes. Diese Objekte werden laufend aktualisiert und besitzen lediglich zur Laufzeit des Szenarios ihre Gültigkeit. Dabei existieren verschiedene Kategorien von Szenarien, siehe Abschnitt \ref{szenarien}. Diese definieren jeweils einen unterschiedlichen Kontext und besitzen daher je nach Szenario zusätzliche Attribute.

\newpage
\paragraph{Konverter}

\begin{wrapfigure}{r}{0.55\textwidth}
	\begin{center}
		\includegraphics[width=0.5\textwidth]{images/uml/json_converter.png}
	\end{center}
	\caption{JsonConverter}
	\label{fig:converter_classdiagram}
\end{wrapfigure}

dienen der Deserialisierung von abstrakten \gls{json} Objekten, welche nicht direkt identifiziert werden können, siehe Abbildung \ref{fig:converter_classdiagram}. Dazu gehören abstrakte Klassen, sowie Schnittstellen, welche keinem spezifischen Objekt zugeordnet werden kann. Die Implementierung erfolgt durch die Überschreibung der entsprechenden Methoden zur Deserialisierung und Serialisierung, siehe Abbildung \ref{fig:ConverterRead} und \ref{fig:ConverterWrite}. Je nach Anwendung, wird ein Parameter übergeben, der das Objekt als Zeichenkette beinhaltet. Dieses wird durch eine Abfolge von Bedingungen auf den Typen geprüft wird, um das Objekt zu erstellen.\\

\begin{figure}[h]
	\centering
	\subfloat[ReadJson]{\includegraphics[width=0.6\textwidth]{images/code/DeviceConverterRead.png}\label{fig:ConverterRead}}
	\qquad
	\subfloat[WriteJson]{\includegraphics[width=0.6\textwidth]{images/code/DeviceConverterWrite.png}\label{fig:ConverterWrite}}
	\caption{Device JsonConverter}
\end{figure}

\newpage
\subsection{\gls{app}}

Die Erstellung der App erfolgt in einer plattformübergreifenden Implementierung durch Xamarin in C\#. Kernelemente stellen hierbei die Struktur, Oberfläche, Businesslogik sowie das Kommunikationssystem dar. Durch die zentrale Verwendung des Kommunikationssystems wird dieses in ein separates Projekt untergliedert, siehe Abbildung \ref{fig:solution} und wird als solches von der \gls{app} als Bibliothek eingebunden. Somit lässt sich die Logik einmalig implementieren und kann auf andere Systemen entsprechend übertragen werden.\\
Die \gls{app} setzt sich aus vier verschiedenen Projekten zusammen, einer \acrshort{pcl} als Projekt zur plattformübergreifenden Entwicklung und den plattformspezifischen Projekten. Diese werden dem Zielsystem entsprechend ausgewählt und erzeugen durch ihre bestehende Referenz auf die \acrshort{pcl} einen plattformspezifischen Quellcode als \gls{il}, der anschließend ausgeführt werden kann. Für eine vollständig detaillierte Darstellung wird auf den Quellcode und den darin enthalten Kommentare sowie das zugehörige 
github-Wiki\\(https://github.com/FleeAndCatch-Dev/FleeAndCatch-Docs/wiki) verwiesen.\\

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.5\textwidth]{images/implementation/solution.png}
	\end{center}
	\caption{Projektstruktur}
	\label{fig:solution}
\end{figure}

\newpage
\subsubsection{Workflow} %Struktur

Die Struktur der \gls{app} basiert auf dem in Xamarin verbreiteten Design Pattern \acrlong{mvvm}, welches durch ein Benachrichtigungssystem zwischen den verschiedenen Strukturen der \gls{app} eine Abspaltung der Daten, \gls{gui} und dem Businesscode erlaubt. Zusätzlich wird die standardmäßig vorhandene CodeBehind Struktur der einzelnen Seiten verwendet, wobei der Businesscode an das Layout der Seite gebunden ist, um diese miteinander zu verbinden. Zur lokalen Speicherung der Daten wird SQLite durch eine implementierte Schnittstelle verwendet, welche plattformübergreifend ansprechbar ist.

\paragraph{\acrfull{mvvm}}

stellt ein Design Pattern dar, welches eine grundlegende Struktur im Quellcode ermöglicht, siehe Abbildung \ref{fig:mvvm}. Dabei wird die erstellte Benutzeroberfläche von der Logik, sowie den Daten getrennt, um Änderungen unabhängig voneinander durchführen zu können. Die einzelnen Objekte werden dabei durch Referenzen verbunden um diese durch Events entsprechend zu aktualisieren.\\

\begin{tabular}{p{2.5cm} p{12.25cm}}
	\textbf{Model:} & Datenschicht, welche durch den Benutzer über die \gls{gui} verändert werden kann und über Datenänderungen die entsprechenden Elemente benachrichtigt \\
	\textbf{View:} & \gls{gui} mit den anzuzeigenden Elementen, welche an das ViewModel gebunden sind und der Benutzerinteraktion dienen. \\
	\textbf{ViewModel:} & Logik des \gls{ui} als zentrale Schnittstelle zwischen dem Model und der View zum Austausch von Informationen, indem entsprechende Methoden und Dienste ausgeführt werden. \\
\end{tabular}

\bigskip

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.95\textwidth]{images/implementation/mvvm.png}
	\end{center}	
	\caption{\acrlong{mvvm} \cite{Brecht.MVVMEntity}}
	\label{fig:mvvm}
\end{figure}

\newpage
\subsubsection{\acrfull{gui}} %Oberfläche

Die Oberfläche der \gls{app} wird mittels \gls{xaml} durch verschiedene von Xamarin zur Verfügung gestellten Elementen realisiert. Da eine \gls{app} ein einfaches Bedienkonzept voraussetzt, damit es von jedem beliebigen Benutzer verwendet werden kann, wird in diesem Projekt, auf das Navigationsprinzip der NavigationPage gesetzt. Die Navigation wird dabei durch das Aufbauen eines Stapels realisiert, was durch das Prinzip eines Stacks in der Programmierung weit verbreitet ist. Dabei wird durch den Aufruf eines Push auf eine neu Seite gewechselt, wobei die alte deaktiviert und hinter die neue im Speicher vorhanden ist, siehe Abbildung \eqref{fig:push}. Dies wird Programm technisch durch eine Liste realisiert, welche langsam aufgebaut wird. Um nun auf eine alte Seite zurück zu gelangen, wird ein Pop verwendet, um die aktuelle Seite sowie deren Daten zu löschen, wobei die vorherige Seite aus dem Speicher geladen wird, siehe Abbildung \eqref{fig:pop}.\\

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.75\textwidth]{images/implementation/push.png}
	\end{center}	
	\caption{Wechsel auf neue Seite \cite{Xamarin.HierarchicalNavigation}}
	\label{fig:push}
	\begin{center}
		\includegraphics[width=0.75\textwidth]{images/implementation/pop.png}
	\end{center}	
	\caption{Wechsel auf alte Seite \cite{Xamarin.HierarchicalNavigation}}
	\label{fig:pop}
\end{figure}

\bigskip

\begin{wrapfigure}{r}{0.5\textwidth}
	\begin{center}
		\vspace{-1cm}
		\includegraphics[width=0.45\textwidth]{images/implementation/stacklayout.png}
	\end{center}
	\caption{StackLayout \cite{Xamarin.StackLayoutXamarin}}
	\label{fig:stacklayout}
\end{wrapfigure}

\noindent
Für das Layout der einzelnen Seiten wird vor allem auf das StackLayout gesetzt. Dieses ist einfach umzusetzen, indem eine vertikale oder horizontale Orientierung zur Anordnung der verschiedenen Elemente festgelegt wird, welche entsprechend ihrer Folge hinzugefügt werden. Zusätzlich können standardmäßige Positionierungen verwendet werden, um das Layout individuell zu beeinflussen.

\begin{verbatim}
\end{verbatim}
\newpage
\paragraph{SignIn Page} stellt die Benutzerschnittstelle zur Anmeldung des Nutzers am System dar, siehe Abbildung \eqref{fig:signin}. Dabei gibt dieser die entsprechende IP-Adresse der laufenden Desktopanwendung zur Verbindung an. Durch eine implementierte Logik wird diese IP-Adresse auf ihre Richtigkeit geprüft und die Verbindung gestartet. Bei einer erfolgreichen Verbindung wird der Benutzer zur Hauptseite weitergeleitet, wodurch ihm die entsprechenden Funktionalitäten zur Verfügung stehen. Andernfalls erscheint nach einem definierten Timeout von drei Sekunden eine Fehlermeldung, welche dem User Informationen zum Fehler vorlegt. Durch ein Switch Element ist zusätzlich die Speicherung der IP-Adresse in einer lokalen Datenbank gegeben, wobei diese bei Start der \gls{app} automatisch geladen und eingefügt wird.\\

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{images/implementation/signin.png}
	\end{center}	
	\caption{SignIn Page}
	\label{fig:signin}
\end{figure}

\newpage
\paragraph{Home Page} stellt die Hauptseite mit der grundlegenden Navigation der \gls{app} dar, siehe Abbildung \eqref{fig:home}. Dabei besitzt der Benutzer die Möglichkeit ein neues Szenario eines Schwarmverhaltens zu starten, Informationen über die \gls{app} abzurufen, oder sich vom aktuelles System abzumelden.

\paragraph{Option Page} stellt die Benutzerschnittstelle dar, welche diesen durch die vorhandenen Szenarien anhand eines Carousels leitet, siehe Abbildung \eqref{fig:option}. Der Nutzer kann damit ein beliebiges Szenario auswählen und die Konfiguration des Schwarmes beginnen.\\

\bigskip

\begin{figure}[h]
	\centering
	\subfloat[Home Page]{\includegraphics[width=0.4\textwidth]{images/implementation/home.png}\label{fig:home}}
	\qquad
	\subfloat[Option Page]{\includegraphics[width=0.4\textwidth]{images/implementation/option.png}\label{fig:option}}
	\caption{Hauptseiten}
\end{figure}

\newpage
\paragraph{List Page} stellt die Benutzerschnittstelle zur Auswahl der Robotern dar, welche im Szenario involviert sein sollen. Dabei kann der Benutzer unter den verschiedenen Typen wählen, wobei die Anzahl der Roboter vom gewählten Szenario abhängt. Sollte eine ungültige Anzahl an Robotern eingegeben werden, erhält der Benutzer eine Rückmeldung, über eine Fehlermeldung und kann dies korrigieren. Bei korrekter Eingabe wird der Benutzer auf eine Seite mit sämtlichen Informationen des Szenarios weitergeleitet und kann dieses starten.\\

\bigskip

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{images/implementation/list.png}
	\end{center}	
	\caption{List Page}
	\label{fig:list}
\end{figure}

\newpage
\paragraph{Szenario Page} stellt die Benutzerschnittselle dar, welche einerseits zur Steuerung und der Überwachung des Schwarmverhaltens dient. Dabei werden laufend die Daten der Roboter, die auf dem \gls{gui} zu sehen sind aktualisiert und entsprechend angezeigt. Die Neigungssensoren des Gerätes, auf dessen Gerät die \gls{app} ausgeführt wird, ermöglichen die Roboter zu steuern, wobei die Richtung und Beschleunigung durch einen Pfeil auf der Oberfläche dargestellt werden. Der Schwarm verhält sich dabei dem entsprechenden Kontext, welchen der Benutzer zuvor eingestellt hat.\\

\bigskip

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{images/implementation/szenario.png}
	\end{center}	
	\caption{Szenario Page}
	\label{fig:szenario}
\end{figure}

\newpage
\subsubsection{Buisnesslogic} %Logik

Die Logik der \gls{app} wird mittels des .NET \gls{framework} in C\# implementiert und ist durch die Strukturierung des \gls{mvvm} Design Pattern in separate Klassen, sowie des eingebundenen Projektes als Bibliothek unterteilt. Diese Logik kann in drei Benutzerszenarien gruppiert werden.
\begin{enumerate}
	\item Anmeldung am System
	\item Erstellung eines Szenario
	\item Ablauf eines Szenario
\end{enumerate}

\begin{wrapfigure}{r}{0.5\textwidth}
	\begin{center}
		\includegraphics[width=0.45\textwidth]{images/implementation/timeout_app.png}
	\end{center}
	\caption{Timeout der Verbindung}
	\label{fig:timeout_app}
\end{wrapfigure}

\paragraph{Die Anmeldung am System} beginnt mit der Validierung der vom Nutzer eingegebenen \gls{ip}-Adresse. Identifiziert wird diese durch die Unterteilung der Zeichenkette in vier Bereiche, welche als Zahl erkannt, und durch einen Punkt abgetrennt sind sowie einen Wertebereich von 0 bis 255 besitzen. Anschließend wird die Verbindung entsprechend konfiguriert, siehe Abbildung \eqref{fig:connect_app} und durch den Aufruf der Methode ConnectAsync() gestartet. Dabei wartet die \gls{app} eine im System fest definierte Zeit von drei Sekunden, siehe Abbildung \eqref{fig:timeout_app}, bis ein Timeout als Fehler geworfen wird, um einen neuen Verbindungsversuch starten zu können.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{images/implementation/connect_app.png}
	\end{center}	
	\caption{Verbindungsaufbau}
	\label{fig:connect_app}
\end{figure}

\noindent
Durch die Speicherung der Verbindung in einer lokalen Datenbank mittels SQLite, siehe Abbildung \eqref{fig:saveip} und \eqref{fig:sqlite} besteht die Möglichkeit eine einmal eingegebene \gls{ip}-Adresse beim Start der \gls{app} wieder zu laden, um diese nicht laufend eingeben zu müssen. Dafür wird eine entsprechende Klasse implementiert, welche die benötigten Daten als Objekt darstellt. Diese Daten werden als Tabellen in der Datenbank ablegt sowie Methoden zu deren Verwaltung bereitgestellt.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.8\textwidth]{images/implementation/authorization.png}
	\end{center}	
	\caption{Speicherung der \gls{ip}-Adresse}
	\label{fig:saveip}
	\begin{center}
		\includegraphics[width=0.8\textwidth]{images/implementation/sqlite.png}
	\end{center}	
	\caption{Definition von SQLite}
	\label{fig:sqlite}
\end{figure}

\noindent
Sobald eine \gls{app} sich erfolgreich mit dem System verbunden hat, läuft neben dem eigentlichen Hauptprozess, welchen der Nutzer durch seine Eingaben steuert ein Nebenprozess. Dieser wartet auf eingehende Kommandos und interpretiert diese nach einem festgelegten Bedingungen in der Interpreter Klasse, um entsprechend zu reagieren oder den Nutzer zu informieren und neue Daten anzuzeigen.

\paragraph{Die Erstellung eines Szenario} beginnt mit der Auswahl eines definierten Typ, wobei jeder einen anderen Kontext besitzt, siehe Abschnitt \eqref{szenarien}. Anschließend gelangt der Nutzer zur Auswahl der verschiedenen Roboter, welche im Szenario teilnehmen sollen. Hierbei wird die entsprechende Zahl an Robotern eines Typs einer Liste hinzugefügt, welche der Nutzer durch die \gls{gui} auswählt, siehe Abbildung \eqref{fig:addrobots}. Sollte der Nutzer dabei eine ungültige Anzahl auswählen, erhält er eine entsprechende Rückmeldung, um eine Korrektur vorzunehmen. Bei erfolgreicher Überprüfung wird das Szenario als Objekt erstellt und enthält somit alle Komponenten sowie zusätzliche Informationen zur Identifikation.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.8\textwidth]{images/implementation/robotlist_add.png}
	\end{center}	
	\caption{Hinzufügen der Roboter}
	\label{fig:addrobots}
\end{figure}

\noindent
Um das erzeugte Szenario zu verifizieren, wird das erzeugt Objekt an die Desktopanwendung versendet, siehe Abbildung \eqref{fig:tryszenario}, welche sämtliche beinhalteten Komponenten der Verfügbarkeit überprüft. Bei erfolgreicher Überprüfung wird der Nutzer zum Start des Szenarios mit einem Überblick auf sämtliche Informationen weitergeleitet. Andernfalls wird die Erstellung abgebrochen und der Nutzer kann Änderungen durchführen.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.7\textwidth]{images/implementation/trycreateszenario.png}
	\end{center}	
	\caption{Erstellung des Szenario}
	\label{fig:tryszenario}
\end{figure}

\paragraph{Der Ablauf eines Szenario} teilt sich in verschiedene Prozesse, wobei der Nutzer durch seine Handlungen im \gls{gui} der Hauptprozess beeinflusst. Daneben existiert ein Prozess zum Datenempfang, welcher Aktualisierungen der Daten des Schwarmes empfängt und entsprechend in der \gls{gui} einpflegt. Zur Steuerung des Schwarmes, dient ein Prozess, der mittels eines Timer laufend neu gestartet wird und somit immer neue Steuerungskommandos versendet sowie die Oberfläche der \gls{app} aktualisiert.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.7\textwidth]{images/implementation/cancelszenario.png}
	\end{center}	
	\caption{Abbruch eines Szenario}
	\label{fig:cancelszenario}
\end{figure}

\noindent
Sobald ein Szenario abgebrochen wird, müssen sämtliche Prozesse und Daten freigegeben werden, damit der Nutzer anschließend ein neues Szenario starten kann, siehe Abbildung \eqref{fig:motionvector}. Dafür wird zunächst der Neigungssensor abgeschaltet, da dieser aktuell nicht mehr benötigt wird. Zur Freigabe der Daten wird sämtliche Aktivität der Roboter abgeschaltet sowie das Szenario entfernt. Dem Backend wird nun noch das Beenden des Szenarios mitgeteilt, damit auch dieses die anderen Komponenten informieren sowie seine Daten freigeben kann.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.7\textwidth]{images/implementation/motionvector.png}
	\end{center}	
	\caption{Neigungssensor}
	\label{fig:motionvector}
\end{figure}

\noindent
Zur Erzeugung eines neuen Steuerungskommandos, siehe Abbildung \eqref{fig:newcommand}, werden die Neigungssensoren des mobilen Gerätes verwendet. Da bei der Implementierung der Schnittstelle auf den verschiedenen Plattformen gewisse Unterschiede bestehen, müssen diese in der plattformübergreifenden Programmierung behoben werden. Dies wird durch eine Angleichung der Faktoren sowie ein vertauschen der Attribute realisiert, wie am Beispiel von Android und Windows. Das Steuerungskommando enthält dabei keine direkten Werte, wie Geschwindigkeit und Winkel, sondern wird durch Zeichenketten (Enums) umgesetzt. Diese verändern ihre Wertigkeit entsprechend der Werten zum Neigungssensor des mobilen Gerätes.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.7\textwidth]{images/implementation/newcommand.png}
	\end{center}	
	\caption{Neues Kommando}
	\label{fig:newcommand}
\end{figure}

\subsection{Roboter}
Die Implementierung des Roboters stellt das Kernstück bei der Realisierung dieses Projekts dar. 
\\
\\
Da eine komplett detaillierte Beschreibung des ganzen Quellcodes den Umfang dieser Ausarbeitung bei weitem sprengen würde,
werden in diesem Kapitel die wichtigsten Implementierungskonzepte deren Funktionswiese, sowie deren Komponenten dargestellt. 
Für eine vollständig detaillierte Darstellung wird auf den Quellcode und den darin enthalten Kommentare sowie das zugehörige 
github-Wiki (https://github.com/FleeAndCatch-Dev/FleeAndCatch-Docs/wiki) verwiesen.
\subsubsection{Threads}
Für die Umsetzung der Szenarien ist es erforderlich das der Roboter verschiedene Dinge parallel erledigt. Zum einen muss die 
ständige und zeitnahen Kommunikation mit dem Backend aufrecht erhalten werden, um zum einen Steuerdaten sowie die Positionsdaten
der anderen Roboter für die Bewegungsberechnung zu empfangen. Andererseits müssen über diese Verbindung die eigenen Daten übermittelt
an das Backend übermittelt werden. Darüber hinaus muss die eigentliche Steuerung des Roboters erfolgen. \\
Zur Realisierung all dieser Aufgaben sind innerhalb des Roboters die folgenden X Threads implementiert:
\begin{itemize}
	%   ###############################################################################################################################
	\item{Hauptthread (main thread)}
	%   ###############################################################################################################################
	\item{Kommunikationsthread (connectionThread)}
	%   ###############################################################################################################################
	\item{Steuerungsthread (steeringThread)}
	%   ###############################################################################################################################
	\item{Datenerfassungsthread (synchronizeThread)}
	%   ###############################################################################################################################
\end{itemize}
In den folgenden Abschnitten werden die einzelnen Threads sowie ihre Aufgaben dargestellt:
\paragraph{Hauptthread}
Der Hauptthread ist der Thread welcher beim Programmstart (Aufruf der Funktion public static void main(String[] args)) automatisch 
erzeugt wird und der immer vorhanden ist. Durch diesen Thread werden in der Initialisierungsphase alle anderen Threads die 
zur Kommunikation, Steuerung und Datenerfassung benötigt werden erzeugt. 
\paragraph{Kommunikationsthread}
\paragraph{Steuerungsthread}
Der Steuerungsthread hat wie der Name schon sagt die Aufgabe den Roboter zu steuern das heiß seine Geschwindigkeit und Bewegungsrichtung 
umzusetzen. Implementiert ist der Steuerungsthread in der RobotController Klasse die als Schnittstelle zwischen der Kommunikation und den
Roboterfunktionalitäten fungiert. \\
Die konkrete Umsetzung der Steuerung die durch diesen Thread erfolgt wird im Abschnitt X.X beschrieben.
\paragraph{Datenerfassungsthread}
Neben dem Empfangen von Daten und der Umsetzung der Steuerung muss der Roboter auch seine eigen Daten wie Position, Orientierung und 
Geschwindigkeit kontinuierlich erfassen und an das Backend übermitteln so das diese Informationen den anderen Robotern zur Verfügung
gestellt werden können. Da dieser Thread dazu auf Funktionalitäten des Roboters zugreift ist auch dieser innerhalb der RoboterController
Klasse implementiert.
\\
Die Realisierung der Datenerfassung ist weit weniger komplex als die der Steuerung des Roboters. 
Die Abbildung X.X zeigt das Zusammenspiel der einzelnen Threads bzw. den Ablauf ihrer Erzeugung und Terminierung:
\subsubsection{Klassen}
Neben den verschiedenen Threads enthält das Roboterprogramm zahlreiche Klassen durch welche die vielfältigen Funktionen abgebildet 
werden die, der Roboter zur Realisierung der verschiedenen Szenarien mitbringen muss. 
\paragraph{Klassenstruktur}
\color{finishing}             % Farbe die angibt welchen Status der folgende Abschnitt hat!
% Eigentlicher Text:
Zur Strukturierung und einer sauberen Trennung der einzelnen Klassen und ihren Sichtbarkeiten, sind diese in verschiedenen 
Paketen (Java-Packages) organisiert. Diese Klassenstruktur ist hierarchisch aufgebaut, orientiert sich an den grundlegenden 
Bestandteilen des Programms (Kommunikation, Roboterkontrolle etc.) und granuliert in einzelnen Unterpakete anhand der Objekten 
welche die jeweiligen Klassen darstellen bzw. welche Funktionen diese bieten. \\
Bei der Umsetzung wurden die Klassen in den folgenden vier großen Paketbereiche strukturiert.
\begin{itemize}
	%   ###############################################################################################################################
	\item{Kommunikation (\code{flee\_and\_catch.robot.communication})} -- Enthält sämtliche Klassen die für die Kommunikation mit dem
	Backend notwendig sind dazu zählen die Eigentlichen Kommunikator (Sockets), die verschieden Kommandos sowie serialisierbare 
	Datenobjekte.
	%   ###############################################################################################################################
	\item{Roboter (\code{flee\_and\_catch.robot.robot})} -- Hier befinden sich alle Klassen die direkten Zugriff bzw. Einfluss auf den 
	physischen Roboter haben. Dies sind hauptsächlich Sensoren, das Roboter-Interface, Klassen die einen konkreten Roboter darstellen, 
	sowie die zentrale Steuerklasse >>RoboterController<<.
	%   ###############################################################################################################################
	\item{View (\code{flee\_and\_catch.robot.view})} -- Enthält Klassen die der Anzeige d.h Ansteuerung des LCD-Displays des
	Roboters dienen. Zwar ist das LCD-Display auch Bestandteil des Roboters, es wurde sich aber für eine Trennung dieser beiden 
	Bereiche entschieden da diese möglichst unabhängig voneinander bleiben sollten.
	%   ###############################################################################################################################
	\item{Konfiguration (\code{flee\_and\_catch.robot.configuration})} -- Zentrales Paket welches Klassen zur Konfiguration 
	der verschiedenen Programmteile enthält.
	%   ###############################################################################################################################
\end{itemize}
Innerhalb dieser Hauptpakete existieren zahlreiche weitere Unterpakete welche die Klassen weiter strukturieren. Die saubere Einordnung
und Trennung der Programmklassen ermöglicht es in Verbindung mit der Festlegung entsprechender Sichtbarkeiten, die Klassen gegeneinander 
abzuschotten. So wird erreicht, dass die Programmteile lediglich über die vorgesehenen Schnittstellen miteinander interagieren und die
einzelnen Klassen nur diejenigen sehen und ansprechen können die sie tatsächlich benötigen. Zudem hilft es dem Programmierer bei der Orientierung und dem Programmverständnis.
\medskip
\newline
In den nächsten Abschnitten werden die wichtigsten Klassen und Interfaces des Programms näher beschrieben und ihre Rolle bei der 
Realisierung des durch die Roboter abgebildeten Schwarmverhaltens erläutern.
\paragraph{Das Roboter Interface}
\color{process}             % Farbe die angibt welchen Status der folgende Abschnitt hat!
% Eigentlicher Text:
Das Roboter Interface dient als Implementierungsvorlage für Klassen die einen Roboter in seiner jeweiligen physischen Gestalt d.h. mit
der jeweiligen Antriebsform, seinen verbauten Sensoren etc darstellen. Innerhalb dieses Interfaces sind sämtliche Funktionalitäten 
und Methoden definiert, die ein konkreter Roboter bzw. die entsprechende Klasse, die diesen repräsentiert implementieren muss um durch 
das Programm gesteuert und in die entsprechenden Szenarien integriert werden zu können. \\
Innerhalb dieses Interface werden dazu verschiedene Methoden zur Steuerung sowie Abfrage von Roboterparametern definiert. Die durch 
diese Methoden dargestellten Funktionalitäten sind von so grundlegender Natur das diese durch jeden Roboter realisiert bzw. umgesetzt 
werden können, wenn auch abhängig von seiner Bauart auf andere Weise. \\
Folgende Auflistung gibt einen Überblick über die wichtigsten diese Methoden und erläutert kurz die durch sie zur realisierende Funktion.
\begin{itemize}
	%   ###############################################################################################################################
	\item{\code{void forward()}} -- Soll den Roboter geradeaus vorwärts fahren lassen.
	%   ###############################################################################################################################
	\item{\code{void backward()}} -- Soll den Roboter geradeaus rückwärts fahren lassen.
	%   ###############################################################################################################################
	\item{\code{void backward()}} -- Soll den Roboter sich nach rechts oder linkes bewegen lassen abhängig von der übergebenen Richtung
	(Direction-Objekt).
	%   ###############################################################################################################################
	\item{\code{void stop()}} -- Soll den Roboter anhalten.
	%   ###############################################################################################################################
	\item{\code{void increaseSpeed()}} -- Soll die Geschwindigkeit des Roboters erhöhen (Iterativ bei jedem Aufruf).
	%   ###############################################################################################################################
	\item{\code{void increaseSpeed()}} -- Soll die Geschwindigkeit des Roboters verringern (Iterativ bei jedem Aufruf).
	%   ###############################################################################################################################
	\item{\code{boolean isMoving()}} -- Soll true zurückgeben wenn sich der Roboter bewegt.
	%   ###############################################################################################################################
	\item{\code{Position getPosition()}} -- Soll die aktuelle Position und Orientierung des Roboters in einem speziellen 
	Position-Objekt zurückgeben.
	%   ###############################################################################################################################
	\item{\code{float getRealSpeed()}} -- Soll tatsächliche (nicht eingestellte) Geschwindigkeit des Roboters zurückgeben.
	%   ###############################################################################################################################
	\item{\code{Robot getJSONRobot()}} -- Soll alle wichtigen Roboterdaten einem speziellen Roboter-Objekt zurückgeben welches 
	serialisierbar ist und damit via JSON-Objekt an des Backend übertragen werden kann.
	%   ###############################################################################################################################
\end{itemize}
Durch die Vorgaben und Verwendung dieser grundlegenden und universellen Funktionalitäten für die Programm-, Szenarien- und Steuerlogik 
ist es mögliche eine generische und flexible Implementierung zu schaffen. Da ein Roboter immer als Objekt dieses Interfaces betrachtet 
und angesprochen wird ist das restliche Programm vollkommen unabhängig von der konkreten Ausprägung des jeweilige Roboter und kennt 
diese nicht mal. Es beschränkt sich bei der Interaktion mit dem Roboter auf die in diesem Interface definierten Methoden. \\
Der Vorteil dieser Implementierung liegt darin, dass durch dieses generische Programmierung lediglich eine neuen Klasse die dieses 
Interface implementiert notwendig ist um einen neue Art von Roboter zu Realisierung und in das Projekt mit sämtlichen Szenarien zu 
integrieren. Dadurch ist das Programm leicht erweiterbar und es steigert seine Wiederverwendbarkeit. \\
Wie diese konkrete Implementierung der durch diese Methoden definierten Funktionen zu realisieren ist hängt natürlich vom jeweilige
Roboter und seinem Aufbau ab und muss durch den Programmiere entsprechend umgesetzt werden.
\paragraph{Die ThreeWheelDrive Klasse (Eine konkrete Roboter Klasse)}
\color{process}             % Farbe die angibt welchen Status der folgende Abschnitt hat!
% Eigentlicher Text:
Die Klasse >>ThreeWheelDrive<< repräsentiert den \glqq{}Standard\grqq{}-Roboter im Projekt. Sie bildet den in Abbildung X.X zu 
sehenden Roboter mit seine relevanten Komponenten wie Sensoren, Motoren sowie relevanten geometrischen und physischen Parametern ab.
Die Klasse implementiert das Roboter-Interface mit den dort definierten Methoden. 
\paragraph{Die RoboterController Klasse}
Die >>RobotController<<-Klasse übernimmt eine zentrale Rolle bei der Umsetzung der Roboter-Steuerung. Die Klasse stellt die Schnittstelle
zum physischen Roboter dar. Sämtliche Steuerkommandos und Sensorabfragen werden über diese Klasse realisiert. Durch diese einheitliche 
Schnittstelle wird es möglich die Steuerung und ... unabhängig von dem konkreten vorhandenen Roboter (Dreirädriger, Vierrädriger etc)
zu realisieren. Dazu nutzt der RoboterController intern eine Instanz des "Roboter" Interfaces was eine Ansteuerung des Roboters 
\\
Die folgende Abbildung zeigt die der verschiedenen Komponenten:
\subsubsection{Steuerung}
Eine der Hauptaufgaben des Roboterprogramms ist die Steuerung des Roboters. Dabei muss das Programm die folgende zwei 
grundlegenden Steuerungsarten unterscheiden und realisieren.
\begin{itemize}
	%   ###############################################################################################################################
	\item{Direkte Steuerung} -- Bei der direkten Steuerung erhält das Programm über das Backend von der App direkte Steuerbefehle wie
	Rechts, Links, Schneller, Langsamer welche das Programm dann in die entsprechende Bewegung des Roboters umsetzen muss.
	%   ###############################################################################################################################
	\item{Indirekte Steuerung} -- Bei der indirekten Steuerung bekommt das Programm keinen konkreten Steuerbefehle sondern muss basierend
	auf den Positionsdaten der anderen Roboter und dem vorherrschenden Szenario die notwendigen Steuerbefehle des Roboters berechnen.
	%   ###############################################################################################################################
\end{itemize}
Dabei erfolgt das Empfangen und Verarbeiten der jeweiligen Daten jeweils zyklisch in einem konfigurierbaren Zeitintervall. Beide Steuerungsarten
basieren auf dem grundlegenden Prinzip das die Daten (Steuerbefehle oder Positionsdaten) durch den X-Thread erfasst und gespeichert werden.
Der Stuerungsthread widerun liest diese Daten aus und führt die entsprechenden Roboterbefehle aus.
\paragraph{Allgemein}
\paragraph{Realisierung beim ThreeWheelDrive}
\subsubsection{Datenerfassung}
\subsection{Backend}
Das Backend ist die Kommunikations- und Verwaltungszentrale des Projekts und bildet das Rückgrat der Kommunikation. Es verwaltet die 
Devices im Kontext der einzelnen Szenarien und sorgt für den Datenaustausch zwischen den verschieden Geräten. \\
Realisiert ist des Backend wie auch der Roboter in der Programmiersprache Java. Das bringt neben der plattformunabhängigen 
Lauffähigkeit des Programms noch weitere Vorteile mit sich. So können vor allem Programmkomponenten welche die Kommunikation und
den Datenaustausch betreffen für die Roboter- bzw. Backend-Implementierung wiederverwendet werden und müssen nicht komplett neu
implementiert werden.
Im Folgenden werden die zentralen Komponenten des Backends vorgestellt.
\subsection{Aufbau}
\subsubsection{Server}
Zur Realisierung der Kommunikation verfügt das Backendprogramm über eine Klasse namens Server. Innerhalb dieser Klasse ist ein
Server-Socket implementiert welches den Endpunkt einer TCP-Verbindung darstellt Abschnitt siehe X.X. Dieses Server-Socket wird
nach dem Programmstart durch aufrufe der Methode \code{open()} mit IP-Adresse und Port initialisiert und kann anschließend 
darüber Nachrichten (z.B. Aufbauanfragen für eine TCP-Verbindung) entgegennehmen. \\
Die Abbildung X zeigt die Funktion \code{open()} welche eine Server-Socket initialisiert und den listenerThread startet.
\begin{figure}[ht]
	\centering
	\includegraphics[width=1.0\textwidth]{images/implementation/SeverOpenMethod.png}
	\caption[\code{open()}-Methode der Sever-Klasse im Backend]{\code{open()}-Methode der Sever-Klasse im Backend}
	\label{fig:ev3system}
\end{figure}
Nach der Initialisierung des Server-Socket wird ein Thread gestartet (listenerThread), welcher zyklisch die Methode \code{listen()}
aufruft. Die Aufgabe dieses Threads ist es kontinuierlich auf Verbindungsaufbauwünsche durch Roboter oder Apps zur warten und bei
deren eintreffen diese zu verarbeiten. \\
Die Abbildung X zeigt die Methode \code{listen()} in der ankommende Verbindungsaufbauwünsche verarbeitet werden.
\begin{figure}[ht]
	\centering
	\includegraphics[width=1.0\textwidth]{images/implementation/SeverListenMethod.png}
	\caption[\code{listen()}-Methode der Sever-Klasse im Backend]{\code{listen()}-Methode der Sever-Klasse im Backend}
	\label{fig:ev3system}
\end{figure}
Trifft ein Verbindungsaufbauwunsch ein wird für diesen, vom Server-Socket ein neues Socket Objekt zurück geliefert welches 
ab sofort eine unabhängige Verbindung zum anfangenden Device repräsentiert und ein Senden von Nachrichten in beide Richtungen 
ermöglicht.\\
Anschließend werden auf diesem Socket-Objekt noch ein paar Optimierungen durchgeführt um die Latenz der Kommunikation mit dem
Device möglichst gering zu halten. Dazu wird zum einen der Nagle-Algorithmus deaktiviert, siehe Abschnitt X sowie entsprechende
Puffergrößen festgelegt. \\
Danach wird ein Thread erzeugt der ab sofort die Kommunikation dieser Verbindung verwaltet. Dazu wird dieser an ein neues Client-Objekt 
gekoppelt, welches das zugehörige Socket-Objekt aufnimmt. Mit der Erzeugung dieses Client-Objekts der Übergabe des Socket-Objekts an diese und
die Zuordnung des entsprechenden Thread zur Verbindungsverarbeitung ist die Verbindung zu einem Device vollständig initialisiert. 
Ab sofort wird das entsprechende Device (App oder Robot) durch das Client-Objekt repräsentiert und kann durch dieses angesprochen werden. Dazu
werden sämtliche Clients in deiner Array-Liste gespeichert und sind durch eine eindeutige ID identifizierbar.
\subsubsection{Client}
Neben der Server Klasse ist die Client Klasse die zentrale Komponente zum Empfangen und Senden von Daten an die einzelnen Devices.
Während die Server-Klasse auf Verbindungsaufbauwünsche der Geräte die sich am Backend anmelden wollen warten, repräsentieren die Clients
eine Device inklusive einer vollwertige TCP-Verbindung.  
\subsubsection{Interpreter}
Die Interpreter Klasse ist zuständig für die Interpretation der am Backend eintreffenden Datenpakete der verschiedenen Devices. Dazu enthält
jedes Client-Objekt eine eigene Instanz der Klasse Interpreter, so dass eine parallele Verarbeitung ohne Beeinflussungen oder Wartezeiten 
möglich ist. \\
Die Interpretation der Datenpakete besteht aus zwei grundlegenden Schritte:
\begin{enumerate}
	%   ###############################################################################################################################
	\item{Parsen des als String vorliegenden Datenpakets in ein JSON-Objekt}
	%   ###############################################################################################################################
	\item{Weiterverarbeitung des JSON-Objekts anhand des vorliegenden Kommandotyps}
	%   ###############################################################################################################################
\end{enumerate}
Den ersten Schritt realisiert die Methode \code{public void parse(String pCommand)}. Zur Umwandlung des vorliegenden Strings verwendet
die Methode dazu eine Funktionalität der Bibliothek >>org.json<<. Anschließend wird das geparste JSON-Object abhängige von seinem
Kommandotyp durch eine entsprechende Methode weiterverarbeitet. \\
Die Abbildung X zeigt den Quellcode des Parse-Vorgangs in der Methode Vorgangs \code{public void parse(String pCommand)}.
\begin{figure}[ht]
	\centering
	\includegraphics[width=1.0\textwidth]{images/implementation/InterpreterParseMethod.png}
	\caption[Ausschnitt der \code{parse()}-Methode der Interpreter-Klasse im Backend]{Ausschnitt der \code{parse()}-Methode der Interpreter-Klasse im Backend}
	\label{fig:ev3system}
\end{figure}
\newline
Die folgende Auflistung zeigt die Methoden der Interpreter Klasse:
\begin{itemize}
	%   ###############################################################################################################################
	\item{\code{public void parse(String pCommand)}} -- Diese Methode führt den eigentlichen Parse-Vorgang durch um das als String
	vorliegende Datenpaket (pCommand) in ein JSON-Objekt zu konvertieren.
	%   ###############################################################################################################################
	\item{\code{private void connection(JSONObject pCommand)}} -- Verarbeitet ein als JSON-Objekt vorliegendes Datenpaket vom Typ 
	Kommandotyp Connection.
	%   ###############################################################################################################################
	\item{\code{private void synchronization(JSONObject pCommand)}} -- Verarbeitet ein als JSON-Objekt vorliegendes Datenpaket vom 
	Typ Kommandotyp Synchronization.
	%   ###############################################################################################################################
	\item{\code{private void szenario(JSONObject pCommand)}} -- Verarbeitet ein als JSON-Objekt vorliegendes Datenpaket vom Typ 
	Kommandotyp Szenario. Dazu existieren folgenden folgende Methoden die die Daten abhängig vom vorliegenden Szenario verarbeiten:
	\begin{itemize}
			%   ###############################################################################################################################
			\item{\code{private void szenarioControl(SzenarioCommand pCommand)}}
			%   ###############################################################################################################################
			\item{\code{private void szenarioSynchron(SzenarioCommand pCommand)}}
			%   ###############################################################################################################################
			\item{\code{private void szenarioFollow(SzenarioCommand pCommand)}}
			%   ###############################################################################################################################
	\end{itemize}
	%   ###############################################################################################################################
	\item{\code{private void exception(JSONObject pCommand)}} -- Verarbeitet ein als JSON-Objekt vorliegendes Datenpaket vom Typ 
	Kommandotyp Exception.
	%   ###############################################################################################################################
\end{itemize}
Aus der Auflistung ist gut ersichtlich das es für jeden Kommandotyp eine eigene Methode zu dessen Verarbeitung implementiert wurde.
Da diese immer nach dem selben Prinzip die Datenverarbeitung vornehmen wird im folgenden exemplarisch auf eine dieser Methode 
eingegangen um dieses Prinzip zu verdeutlichen. \\

\subsubsection{Device \& Szenario Controller}
Neben den für die Kommunikation wichtigen Komponenten spielen bei der Realisierung des Backends auch die Controller-Klassen eine 
zentrale Rolle, da diese wichtige Verwaltungsfunktionen bereit stellen. Sie sind für die Verwaltung der verschiedenen Devices 
und Szenarien zuständig. \\
Dazu existieren die folgenden Controller-Klassen:
\begin{itemize}
	%   ###############################################################################################################################
	\item{AppController} -- Der AppContoller verwaltet alle am Backend angemeldeten Apps.
	%   ###############################################################################################################################
	\item{RobotContoller} -- Der RoboterContoller verwaltet alle am Backend angemeldeten Roboter.
	%   ###############################################################################################################################
	\item{ScenarioController} -- Der AppContoller verwaltet sämtliche aktiven Szenarien.
	%   ###############################################################################################################################
\end{itemize}
Die beiden Klassen AppController und RoboterController bestehen im wesentlichen aus einer ArrayList, in welcher sämtliche Apps bzw. 
Roboter die am Backend angemeldet sind gespeichert werden. Dazu werden die Devices durch Objekte entsprechender Klassen in der 
ArrayList repräsentiert. 

Alle drei Klassen arbeiten mit statischen Datenstrukturen und Methoden da sie ...
\subsubsection{Die GUI}
Neben den rein Funktionalen Komponenten des Backends verfügt dieses auch über eine grafische Benutzeroberfläche die Informationen zu
den angemeldeten Geräten und den existierenden Szenarien zur Verfügung stellt. Diese Benutzeroberfläche ist so realisiert das diese 
komplett losgelöst von den der eigentlichen Funktionalität des Backend ist. Sie setzt lediglich auf dem eigentlichen Programm auf und
ist zu dessen Ausführung nicht notwendig. Dadurch ist es möglich das Programm komplett ohne grafische Benutzeroberfläche zu starten so
das es im Hintergrund laufen kann und lediglich als Verwaltungs- und Kommunikationsservice dient. Ob die grafische Benutzeroberfläche  
aktiviert ist oder nicht wird beim Programmstart durch entsprechenden Parametern festgelegt. \\
Der Nutzen der GUI bestand für uns hauptsächlich im Monitoring und bei der Identifikation sowie dem Aufspüren von Fehlern während der 
Entwicklung. \\
Realisiert ist die grafische Benutzeroberfläche mit dem JavaFX-Framework welches Bestandteil der Java-Bibliothek ist uns somit wie 
Java ebenfalls plattformunabhängig lauffähig ist. Zu ihrer Ansteuerung dient eine spezielle Klasse namens
>>ViewController<< welche lediglich Informationen des eigentliche Programms entgegen nimmt und an die eigentliche Benutzeroberfläche 
(View) weiterreicht sofern diese aktiviert wurde. Umgekehrt werden jedoch keine Benutzereingaben von der GUI an das Programm 
weitergereicht, sondern dienen lediglich zur Manipulation der Anzeige so das dieses komplett unabhängig ist. Lediglich das Beenden 
das kompletten Programms ist über die grafische Benutzeroberfläche möglich.
Abbildung X.X zeigt einen Screenshot der grafischen Benutzeroberfläche des Backends. \\
\\
Da die grafische Benutzeroberfläche jedoch nicht zur eigentlichen Funktionalität des Backends beiträgt soll an dieser Stelle nicht 
weiter eingegangen werden.
\begin{comment}
Aufbau
Interpreter
Mechanismen
GUI
\end{comment}


\begin{comment}
Aufbau
Robot
RobotController
EV3 Library
GUI
\end{comment}